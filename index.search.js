var relearn_search_index = [
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Ecosystem",
    "content": "VSS can be transformed into other formats or generated as code to integrate with other tooling environments and ecosystems.\nThe COVESA vss-tools project contains various helpful converters and is also used to validate the syntactic validity of the VSS standard catalogue.\nIf new features are introduced to the VSS specification, the community will ensure they are supported in the official vss-tools as well.\nFig 1. Generating various output formats from a VSS specification",
    "description": "VSS can be transformed into other formats or generated as code to integrate with other tooling environments and ecosystems.\nThe COVESA vss-tools project contains various helpful converters and is also used to validate the syntactic validity of the VSS standard catalogue.\nIf new features are introduced to the VSS specification, the community will ensure they are supported in the official vss-tools as well.\nFig 1. Generating various output formats from a VSS specification",
    "tags": [],
    "title": "Official VSS-Tools",
    "uri": "/vehicle_signal_specification/ecosystem/tools/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set",
    "content": "Specification format The Vehicle Signal Specification domain specification consist of vspec files. vspec files are YAML files following the rule set defined for VSS. They also support the use of include directives to refer to other vspec files, much like #include in C/C++. . Please note that, from a YAML perspective, the include directive is just another comment.\nThe file VehicleSignalSpecification.vspec serves as root and includes other vspec files from the VSS repository.\nThe raw specification files can, with help of tools in the vss-tools repository, be converted to other formats that are more user friendly to read. Converted representations are also included as release artifacts for each VSS release.\nVSS is in itself case sensitive. This means that keywords, signal names, types and values normally shall be given with the case specified. It is however recommended not to take advantage of this and reuse the same name with different case, as some implementations may treat VSS identifiers as case insensitive.\nAddressing Nodes VSS supports only a single tree, that means that all signals must belong to the same root. In the VSS standard catalog the root branch is called Vehicle, so all signals must be part of the Vehicle tree.\nTree nodes are addressed, left-to-right, from the root of the tree toward the node itself. Each element in the name is delimited with a period (\".\"). The element hops from the root to the leaf is called path\nFor example, the dimming status of the rearview mirror in the cabin is addressed:\nVehicle.Cabin.RearviewMirror.Dimmed If there are an array of elements, such as door rows 1-3, they will be addressed with an index branch:\nVehicle.Cabin.Door.Row1.Left.IsLocked Vehicle.Cabin.Door.Row1.Left.Window.Position Vehicle.Cabin.Door.Row2.Left.IsLocked Vehicle.Cabin.Door.Row2.Left.Window.Position Vehicle.Cabin.Door.Row3.Left.IsLocked Vehicle.Cabin.Door.Row3.Left.Window.PositionIn a similar fashion, seats are located by row and their left-to-right position.\nVehicle.Cabin.Seat.Row1.Pos1.IsBelted # Left front seat Vehicle.Cabin.Seat.Row1.Pos2.IsBelted # Right front seat Vehicle.Cabin.Seat.Row2.Pos1.IsBelted # Left rear seat Vehicle.Cabin.Seat.Row2.Pos2.IsBelted # Middle rear seat Vehicle.Cabin.Seat.Row2.Pos3.IsBelted # Right rear seatThe exact use of PosX elements and how they correlate to actual positions in the car, is dependent on the actual vehicle using the spec.\nParent Nodes If a new leaf node is defined, all parent branches included in its name must be included as well, as shown below:\n[Signal] Vehicle.Cabin.Door.Row1.Left.IsLocked [Branch] Vehicle.Cabin.Door.Row1.Left [Branch] Vehicle.Cabin.Door.Row1 [Branch] Vehicle.Cabin.Door [Branch] Vehicle.Cabin [Branch] VehicleThe branches do not have to be defined in any specific order as long as each branch component is defined somewhere in the vspec file (or an included vspec file).\nDeprecation since version 2.1 During the process of model development, nodes might be moved or deleted. Giving developers a chance to adopt to the changes, the original nodes are marked as deprecated with the following rules.\nNodes, which are moved in the tree or are intended to be removed from the specification are marked with the deprecation keyword. The string following the deprecation keyword shall start with the version, when the node was deprecated starting with V (e.g. V2.1) followed by the reason for deprecation. If the node was moved, it shall be indicated by moved to followed by the new node name in dot notation as deprecation reason. This keyword shall be used only if the meta-data of the moved node hasn’t changed. If the node is intended to be removed from the specification or the meta data changed, it shall be indicated by removed and optionally the reason for the removal as deprecation reason. Nodes which are deprecated will be removed from the specification, either in the second minor update or, if earlier, the next major update. Example Vehicle.Navigation.CurrentLocation: type: branch description: The current latitude and longitude of the vehicle. deprecation: V2.1 moved to Vehicle.CurrentLocationIt is recommended for servers, which are implementing protocols for the vehicle signal specification, to serve old and new nodes during the deprecation period described above.\nStyle Guide The VSS specification must adhere to YAML syntax. To keep the standardized VSS specification in this repository consistent the following style guide is provided.\nNaming Conventions Node names in VSS must follow the restrictions specified in Yaml i.e. must only use the printable subset of the Unicode character set.\nTools and Generators supporting VSS may however put additional restrictions on which characters that are allowed. For maximum portability, node names in the VSS standard catalog must fulfill the following rules\nNode names in the VSS standard catalog shall use camel case notation starting with a capital letter. Node names in the VSS standard catalog shall use only A-Z, a-z and 0-9 in node names. Boolean signals must start with Is. Node names are case insensitive for comparison operations, therefore the full path of node names must be unique e.g. Vehicle.Abc and Vehicle.ABC are the same in comparison and therefore the presence of both is prohibited. Examples:\nVehicle.Cabin.Door.Row1.Left.IsLockedNaming convention for string literals can be found in the chapterfor specifying allowed values.\nLine Length It is recommended that line length for files in this repository ( e.g. *.vspec and *.md files) shall not exceed 120 characters. This is not a strict limit, it is e.g. not recommended to split long URLs over multiple lines.",
    "description": "Specification format The Vehicle Signal Specification domain specification consist of vspec files. vspec files are YAML files following the rule set defined for VSS. They also support the use of include directives to refer to other vspec files, much like #include in C/C++. . Please note that, from a YAML perspective, the include directive is just another comment.\nThe file VehicleSignalSpecification.vspec serves as root and includes other vspec files from the VSS repository.",
    "tags": [],
    "title": "Basic Rules",
    "uri": "/vehicle_signal_specification/rule_set/basics/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set",
    "content": "A branch entry describes a tree branch (or node) containing other branches and signals.\nA branch entry example is given below:\nVehicle.Trunk: type: branch description: All signals related to the rear trunk aggregate: falseEach data entry has a name, in the example above Vehicle.Trunk. VSS use a dot-notated name style where the full path of a branch consists of all parent branches from the root node separated by dots and at the end the name of the current branch. In the standard VSS catalog the root node is called Vehicle.\nWhen using *.vspec files to define a VSS catalog it is not necessary to give the full dot-notated name for each branch as the *.vspec format supports includes that can be used to append entries to a specific branch.\nMandatory Branch Attributes This is the list of attributes that must be specified for every data entry.\nAttribute Description Comment type Defines the type of the node. For a branch this must be branch. The default for type is branch. description Describes the meaning and content of the branch. Recommended to start with a capital letter and end with a dot (.). Optional Data Entry Attributes In additon to the mandatory attributes some optional attributes have been defined. There may be additional constraints on their usage not specified in the table below.\nAttribute Description Comment comment A comment can be used to provide additional informal information on a branch. This could include background information on the rationale for the branch, references to related branches, standards and similar. Recommended to start with a capital letter and end with a dot (.). since version 3.0 instances For specifying that multiple instances of this branch exist, for more information see documentation on instances. aggregate Defines whether or not this branch is an aggregate. If not defined, this defaults to false. An aggregate is a collection of signals that make sense to handle together in a system. A typical example could be GNSS location, where latitude and longitude make sense to read and write together. This is supposed to be deployment and tool specific, and for that reason no branches are aggregates by default in VSS. For branches that both have instances defined and aggregate: true, then aggregate refers to the signals for individual instances, i.e. signals for different instances can be handled separately. ",
    "description": "A branch entry describes a tree branch (or node) containing other branches and signals.\nA branch entry example is given below:\nVehicle.Trunk: type: branch description: All signals related to the rear trunk aggregate: falseEach data entry has a name, in the example above Vehicle.Trunk. VSS use a dot-notated name style where the full path of a branch consists of all parent branches from the root node separated by dots and at the end the name of the current branch.",
    "tags": [],
    "title": "Branch Entry",
    "uri": "/vehicle_signal_specification/rule_set/branches/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Introduction",
    "content": "What is VSS? The Vehicle Signal Specification introduces a domain taxonomy for vehicle signals. In short this means that VSS introduces:\nA syntax for defining vehicle signals in a structured manner. A catalog of signals related to vehicles. It can be used as standard in automotive applications to communicate information around the vehicle, which is semantically well defined. It focuses on vehicle signals, in the sense of classical attributes, sensors and actuators with the raw data communicated over vehicle buses and data which is more commonly associated with the infotainment system alike.\nA standardized vehicle data specification allows an industry actor to use a common naming space for communication and, ultimately, abstracts underlying vehicle implementation details.\nWhile the data in the VSS standard catalog aims to be vendor-independent, vendor specific extensions and adaptations complying with the VSS syntax rules can be specified (see Overlays).\nWhat’s in Standardized data definition for vehicle signals. Same semantic understanding across different domains. Basic definition for interfaces working on vehicle data (w3c, etc.). What’s out Everything outside the vehicle signal domain (customer, weather, etc.). Concrete interface definition. Example The figure below shows an example snapshot of a generated tree of the specification. The leafs contain the actual information as shown in the figure. Before going into detail of the specification, let’s dig deeper into taxonomies.\nVSS usage for other domains The VSS catalog focuses on signals related to vehicles. It is not the intention of the VSS project to add signals for other domains. The syntax used for defining VSS signals and related tooling could however be used to define similar signal trees for other domains.",
    "description": "What is VSS? The Vehicle Signal Specification introduces a domain taxonomy for vehicle signals. In short this means that VSS introduces:\nA syntax for defining vehicle signals in a structured manner. A catalog of signals related to vehicles. It can be used as standard in automotive applications to communicate information around the vehicle, which is semantically well defined. It focuses on vehicle signals, in the sense of classical attributes, sensors and actuators with the raw data communicated over vehicle buses and data which is more commonly associated with the infotainment system alike.",
    "tags": [],
    "title": "Overview",
    "uri": "/vehicle_signal_specification/introduction/overview/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Ecosystem",
    "content": "Other standards or specifications sometimes reference VSS.\nCOVESA VISS When using VSS in an automotive tech stack, a question is which protocols and technologies to use to access VSS signals.\nThe COVESA Vehicle Information Service Specification (VISS) is an open standard, specifying a protocol to access VSS data using JSON messages on transport protocols like websocket (VISSv1), HTTP, MQTT (+VISSv2), or gRPC (+VISSv3).\nTo learn more check\nVehicle Information Service Specification (VISS) V1 published as a Discontinued Draft. Vehicle Information Service Specification (VISS) V2.0. Vehicle Information Service Specification (VISS) V3.0. W3C VSSo If you want to interconnect VSS data with other domains, you might want to employ ontology-based tech stacks. The W3C VSS Ontology enables you to express VSS in form of an OWL ontology.\nTo learn more check\nVSSo Core: Vehicle Signal Specification Core Ontology ",
    "description": "Other standards or specifications sometimes reference VSS.\nCOVESA VISS When using VSS in an automotive tech stack, a question is which protocols and technologies to use to access VSS signals.\nThe COVESA Vehicle Information Service Specification (VISS) is an open standard, specifying a protocol to access VSS data using JSON messages on transport protocols like websocket (VISSv1), HTTP, MQTT (+VISSv2), or gRPC (+VISSv3).\nTo learn more check\nVehicle Information Service Specification (VISS) V1 published as a Discontinued Draft.",
    "tags": [],
    "title": "Related Standards",
    "uri": "/vehicle_signal_specification/ecosystem/standards/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set",
    "content": "Leaf nodes of the tree contain metadata describing the data associated to the node. In order to help application developers, who are using the specification, it makes a distinction between three types of signals:\nsensor actuator attribute Examples and more information you’ll find in the Sensors, Actuators and Attributes chapter.",
    "description": "Leaf nodes of the tree contain metadata describing the data associated to the node. In order to help application developers, who are using the specification, it makes a distinction between three types of signals:\nsensor actuator attribute Examples and more information you’ll find in the Sensors, Actuators and Attributes chapter.",
    "tags": [],
    "title": "Data Entry",
    "uri": "/vehicle_signal_specification/rule_set/data_entry/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Introduction",
    "content": "The figure below explains the idea of a taxonomy as bridge between human and machine understanding of data. It is important to focus on a specific domain to get common understanding and acceptance. The link between two or more domain taxonomies can be seen as second step.\nComponents of a domain taxonomy A domain taxonomy, like VSS, consists of three important components, which will be discussed in detail in this documentation:\n1. Rule Set, as definition on how to describe the data definition syntactically.\n2. Data Definition, as description of the domain as a simple graph.\n3. Tools and Serialization, generates the serialization out of the data Definition for further usage.",
    "description": "The figure below explains the idea of a taxonomy as bridge between human and machine understanding of data. It is important to focus on a specific domain to get common understanding and acceptance. The link between two or more domain taxonomies can be seen as second step.\nComponents of a domain taxonomy A domain taxonomy, like VSS, consists of three important components, which will be discussed in detail in this documentation:",
    "tags": [],
    "title": "Taxonomies",
    "uri": "/vehicle_signal_specification/introduction/taxonomy/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Ecosystem",
    "content": "Various software frameworks and products exist to work with VSS data. Some are Open Source, some are commercial prducts and services. There are solutions to work with VSS in-vehicle, as well as using it in the cloud.\nThe best entry-point for an up-to-date introduction to VSS products and Use Cases is the COVESA VSS wiki.",
    "description": "Various software frameworks and products exist to work with VSS data. Some are Open Source, some are commercial prducts and services. There are solutions to work with VSS in-vehicle, as well as using it in the cloud.\nThe best entry-point for an up-to-date introduction to VSS products and Use Cases is the COVESA VSS wiki.",
    "tags": [],
    "title": "Software \u0026 Solutions",
    "uri": "/vehicle_signal_specification/ecosystem/software/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set",
    "content": "VSS resembles primarily the physical structure of the vehicle, so quite often there is a need to repeat branches and data entries (e.g. doors, axles, etc). To avoid hard-coded repetitions of branches and data entries in the specification an instance-concept is supported. Instances remove the need of repeating definitions, by defining at the node itself how often it occurs in the resulting tree. They are meant as a short-cut in the specification and interpreted by the tools. As an example is shown below for doors:\nWhen expanded this corresponds to:\nDefinition How can I create instances for my branch? An instance can be defined in any branch. The instantiation is done for every node in the following path. Instances are defined with the key-word instances, followed by its definition, which can be either: a list of strings, where each element defines a single instance, e.g. ['DriverSide','PassengerSide'] results into two instances of every following data entry in the path, named DriverSide and PassengerSide a string, followed by a range defined through [n,m], with n,m as integer and n \u003c= m, which defines the number of instances. Position[1,4] results into 4 instances of every following data entry in the path, named Position1, Position2, Position3 and Position4. If multiple instances occur in one node or on the path to a data entry, the instances get combined, by the order of occurrence. Following the example above, four position instances will be created for each of the ‘DriverSide’ and ‘PasengerSide’ instances, resulting into a total number of 8 instances. Use of instances in VSS Standard Catalog The VSS standard catalog is configured to represent a typical passenger vehicle, with two axles and two rows of seats. For other vehicles, see recommendations on instance mismatch below.\nTypical naming conventions used in VSS standard catalog include:\nWhen instances are defined by a range, e.g., Position[m,n], VSS standard catalog uses 1 as start index for the first instance. The instance definition Row[n,m], e.g., Row[1,2], is used to indicate that there are multiple rows of the entity. Rows are counted from the front of the vehicle. For items located on either left or right side of the vehicle VSS standard catalog uses two different conventions: In some cases instances are defined relative to driver position, e.g., [\"DriverSide\", \"PassengerSide\"]. In other cases instances are defined based on physical position, e.g., [\"Left\",\"Right\"]. How can I exclude child-nodes from instantiation? Often it makes sense to instantiate all child-nodes of a branch. But there could be cases, when nodes are linked more the general concept of a branch, but not to the single instance.\nTo exclude a child-node from the instantiation of the direct parent node, set the keyword instantiate to false (true by default). Please check the following example for details.\nExample The example from above in the specification:\n# Cabin.vspec Door: type: branch instances: - Row[1,2] - [\"DriverSide\",\"PassengerSide\"] description: All doors, including windows and switches #include SingleDoor.vspec Door Door.SomeSignal: datatype: uint8 type: attribute instantiate: false description: A door signal that should not be instantiated.# SingleDoor.vspec # # Definition of a single door # IsOpen: datatype: boolean type: actuator description: Is door open or closedResults in the following signals:\nVehicle.Cabin.Door.SomeSignal Vehicle.Cabin.Door.Row1.DriverSide.IsOpen Vehicle.Cabin.Door.Row1.PassengerSide.IsOpen Vehicle.Cabin.Door.Row2.DriverSide.IsOpen Vehicle.Cabin.Door.Row2.PassengerSide.IsOpenRedefinition It is possible to override the default instantiation provided by VSS by redefining the branch with different instantiation information. If multiple definitions of a branch exist with different instance definitions, then the last found definition will be used. As an example, if three row of doors are needed, then the default VSS instance definition can be overridden by redefining the Door branch as shown in the example below.\n#Redefinition changing number of rows from 2 to 3 #The redefinition must appear \"after\" the original definition Vehicle.Cabin.Door: type: branch instances: - Row[1,3] - [\"DriverSide\",\"PassengerSide\"] description: All doors, including windows and switchesRecommendations VSS standard catalog is designed to cover a wide range of vehicles. This means that the default instantiation used in VSS may not fit every vehicle. An example can be seen in the windshield signals defined in Body.vspec, parts of them are shown below. VSS offers the possibility to control windshield heating separately for front and rear windshield, and VSS also gives the possibility to report washer fluid level separately for each windshield. This fits very well for a vehicle that has separate washer fluid containers for front and rear windshield and that offers heating for both windshields. But that is not the case for all vehicles, it is not even certain that all vehicles have two windshields. This sections gives recommendations on how to use VSS for a vehicle if the VSS specification does not offer an exact match of the capabilities of the vehicle.\nWindshield: type: branch instances: [\"Front\", \"Rear\"] description: Windshield signals Windshield.Heating: type: branch description: Windshield heater signals Windshield.Heating.Status: datatype: boolean type: actuator description: Windshield heater status. 0 - off, 1 - on Windshield.WasherFluid: type: branch description: Windshield washer fluid signals Windshield.WasherFluid.LevelLow: datatype: boolean type: sensor description: Low level indication for washer fluid. True = Level Low. False = Level OK.Recommendation: Instance Mismatch If a vehicle does not have as many instances as specified in VSS then one of the following methods are recommended:\nRedefine the branch. If a vehicle for example does not have a rear windshield then change instance definition in an overlay : Vehicle.Body.Windshield: type: branch instances: [\"Front\"] description: Windshield signals Accept that a branch Vehicle.Body.Windshield.Rear will exist in the generated VSS representation. Use mechanisms outside VSS to ignore that branch. Recommendation: Features shared among instances If a feature is shared among instances, it is recommended to publish that feature for all concerned instances.\nExample: In VSS washer fluid can be handled separately for front and rear windshield. If a vehicle use a common container serving both front and rear windshield, then it is recommended that the vehicle report information on that container in both Vehicle.Body.Windshield.Front.WasherFluid.LevelLow and Vehicle.Body.Windshield.Rear.WasherFluid.LevelLow.\nRecommendation: Features lacking for some instances Not all instances in a vehicle might have the same features. If e.g. the front windshield from the example above lack a heater, then it is recommended to use mechanisms outside VSS to ignore Vehicle.Body.Windshield.Front.Heating.",
    "description": "VSS resembles primarily the physical structure of the vehicle, so quite often there is a need to repeat branches and data entries (e.g. doors, axles, etc). To avoid hard-coded repetitions of branches and data entries in the specification an instance-concept is supported. Instances remove the need of repeating definitions, by defining at the node itself how often it occurs in the resulting tree. They are meant as a short-cut in the specification and interpreted by the tools.",
    "tags": [],
    "title": "Instances",
    "uri": "/vehicle_signal_specification/rule_set/instances/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set",
    "content": "An include directive in a vspec file will read the file it refers to and the contents of that file will be inserted into the current buffer in place of the include directive. The included file will, in its turn, be scanned for include directives to be replaced, effectively forming a tree of included files.\nSee Fig 6 for an example of such a tree.\nFig 6. Include directives\nThe include directive has the following format:\n#include \u003cfilename\u003e [prefix] The \u003cfilename\u003e part specifies the path, relative to the file with the #include directive, to the vspec file to replace the directive with. Additionally, include paths to search for the file can be added when using vss-tools using the -I/--include-dirs. The order of include paths to be searched is first the relative path of the vspec specifying the include and then given include paths in the given order.\nThe optional [prefix] specifies a branch name to be prepended to all signal entries in the included file. This allows a vspec file to be reused multiple times by different files, each file specifying their own branch to attach the included file to.\nAn example of an include directive is:\n#include doors.vpsec chassis.doors The door.vspec section specifies the file to include.\nThe chassis.doors section specifies that all signal entries in door.vspec should have their names prefixed with chassis.doors.\nIf an included vspec file has branch or signal specifications that have already been defined prior to the included file, the new specifications in the included file will override the previous specifications.\nREUSING SIGNAL TREES Complete subtrees of signals can be reused by including them multiple times, attaching them to different branches each time they are included.\nAn example is given in Fig 7 where a generic door signal specification is included four times to describe all doors in the vehicle.\nFig 7. Reusing signal trees\nThe door.vspec file is included four times by the master root.vspec file. The signals of door.vspec, Locked, WinPos, and Open are attached on the front left and right doors of row 1 (front) and row 2 (back).\nIf door.vspec is changed, the changes will be propagated to all four doors.",
    "description": "An include directive in a vspec file will read the file it refers to and the contents of that file will be inserted into the current buffer in place of the include directive. The included file will, in its turn, be scanned for include directives to be replaced, effectively forming a tree of included files.\nSee Fig 6 for an example of such a tree.\nFig 6. Include directives\nThe include directive has the following format:",
    "tags": [],
    "title": "Includes",
    "uri": "/vehicle_signal_specification/rule_set/includes/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e VSS Catalog",
    "content": "Introduction In modern vehicles multiple electronic controlled systems are interacting to realize the overall vehicle motion in all physical directions. Typically, the driver gives input e.g. using the steering wheel and the accelerator and brake pedals, but additional vehicle functions may have also requests towards the motion actuators. One example is that a traction control system may want to limit the performance due to slippery road conditions or that the emergency braking system requests braking.\nA number of signals have been added to VSS related to powertrain (eAxle), steering and braking. These signals may be used to define actuator interfaces to support a highly flexible functional deployment on different electronic control units. Vehicle motion functions like driver brake request, cooperative regenerative braking and traction control system may request target values for longitudinal control on vehicle, axle and wheel level. Therefore, generic interface signals for the braking systems are introduced which support an arbitration of the requested target values by minimum and maximum values. The signal definitions for powertrain and steering are based on state-of-the art interfaces which are widely used in the automotive industry. VSS does not specify the implementation of the interface signals and the arbitration cascade, but possible examples are given below.\nDefinitions and Assumptions If nothing else is specified, the following definitions and assumptions apply\nThe specified data types are chosen based on state-of-the art interfaces for vehicle internal communication between chassis ECUs. All datatypes int/uint may represent decimal numbers, therefore additional computational methods could be specified in upcoming VSS releases.\nMain guiding units for vehicle motion brake control:\nVehicle level: Force requests Axle level: Torque requests Wheel level: Torque requests, omega limits (wheel-spin velocity according to ISO 8855) Brake forces on vehicle level are defined by the sum of all wheel forces that control the vehicle along the driving path. Brake torques on axle level are defined as the sum of torques on all wheels on that axle. Brake torques and omega limits on wheel level are defined for each individual wheel of the vehicle.\nSignal orientation brake system: Requests are positive in desired path direction of the vehicle. The desired path direction is defined by the intended driving selection (P,R,D,N). This means that a positive value indicates acceleration, a negative value deceleration with respect to the intended driving selection.\nOmega limits for brake system defined as relative to actual driving direction. This means that omega is never negative.\nTorque and Force distribution signals (between front/rear axle or left/right wheel) are based on the assumption that all wheels/axles exercise torque in the same direction, i.e. a single axle/wheel cannot fulfil more than 100% of the total request.\nSignal orientation steering system: Requests are defined according to ISO 8855. For steering related signals, a positive request on the front axle unless otherwise stated yields to steer the vehicle to the left.\nSignal orientation eAxle system: Requests are defined according to ISO 8855. This means that a positive torque yields to a force in vehicle forward direction and a negative torque yields to a force in backward direction. Omega limits for eAxle system defined according. Positive sign for rotation in forward direction, negative sign for rotation in backward direction. So the sign of current omega of a eAxle indicated the current driving direction.\nAll signals are defined in an automotive safety context, i.e. ISO 26262 has to be considered while using specified signals in vehicle applications.\nSensors vs. Actuators The type actuator is selected to define that the signal may be used as a “request” by vehicle systems/services towards the actuator. The type sensor is selected for signals that are processed by the actuator and may be used as actuator feedback towards the requesting vehicle systems/services.\nBraking System The defined braking signals are the main signals for interacting between vehicle motion features and the braking system including the arbitration of longitudinal vehicle requests. The interface signals are specified on vehicle-, axle- and wheel-level and the arbitration concept supports a flexible integration of vehicle motion features on different ECUs. The arbitration of multiple vehicle motion features can result in a sophisticated arbitration logic to ensure the vehicle stability and driver safety, which is not part of VSS signal catalogue. However, the specified vehicle signals shall support different arbitration logics. The following section shows some hypothetical examples for arbitration.\nExample 1 - vehicle force requests (Vehicle.MotionManagement.Brake.VehicleForceMaximum) Driver request via brake pedal -2000N. Advanced driving assistance system for automated emergency brake has a request of -3000N. As a result, a vehicle force of -3000N would be applied, to ensure maximum deceleration.\nExample 2 distribution request (Vehicle.MotionManagement.Brake.VehicleForceDistributionFrontMinimum/ Maximum) Vehicle force request of -3000N of example 1.\nA vehicle energy function requests a AxlePercentRangeDistributionFrontMaximum of 100% to be most energy efficient. The vehicle stability function could limit this distribution of 20% \u003c x \u003c 80% due to the current driving situation. As a result, only 80% axle distribution would be arbitrated, e.g. -600N force (braking) on rear axle and -2400N force (braking) on front axle.\nPowertrain System (Electrical Axle) A vehicle may have an arbitrary number of electrical axles. Rotational speed and torque for an electrical axle refer to the axle coming out of the electrical axle unit. There may be a transmission/gearbox between the electrical axle and the actual wheels served by the electrical axle.\nThere are two operation modes of an eAxle: torque control or speed control.\nTorque Control A torque request (e.g. 50Nm) is realized by the eAxle. In addition, limit for the rotational speed can be defined, e.g. -5000 rpm … +5000 rpm. These limits are useful to avoid too high wheelspin when the vehicle is on a slippery road. This mode is used most of the time, when the eAxle is active.\nSpeed Control A rotational speed request (e.g., 1000rpm) is realized by the eAxle. This mode is useful for low speed till standstill, because so the vehicle can be controlled easier to a standstill, especially on a rough road.\nSteering System The defined steering signals are the main signals for interacting between vehicle motion features and the steering system on the front axle and are widely used in automotive industry. These signals are specified in a generic way to support various steering systems like electric power steering as well as Steer-by-Wire. Therefore, not all signals must necessarily be available/applicable. The signal specification supports requests on steering wheel (torque and angle) and the steering rack position which is linked to the steered wheels of the vehicle. The signal requests are further divided in “offset” and “target” signals, where an offset value is used additive to the functionality of the steering system and a “target” value is used as absolute external set-point for steering actuation. The different requests are controlled by dedicated “mode” signals for enabling and disabling the steering requests.\nExamples: Driving in a left curve and applying external requests to steering system. Based on the stationary driving without external request (config 1) the principle effects of the different steering interface signals are explained for each interface signal exlusively (config 2…6). Depending on the concrete use case a combination of parallel requested interface signals is applicable.\nConfig Current.SteeringWheelTorque (Torque Applied by Driver) Current.SteeringWheelAngle Current.RackPositionFrontAxle Result/Comment 1: Regular turn - No external request 3 Nm 20 degree 4 mm “Steering support” (e.g. power steering) require driver to apply 3 Nm to continue turning with same radius. 2. Lane Assist Intervention - SteeringWheelTorqueOffsetTarget = 2 Nm 5 Nm* 20 degree 4 mm Driver torque needs to be increased to continue turning with same radius 3. Torque Target Changed - SteeringWheelTorqueTarget = 2 Nm 2 Nm* 20 degree 4 mm Required driver torque set to 2 Nm (e.g. external steering feel for steer by wire), offset ignored. 4. Autonomuos Driving - SteeringWheelAngleTarget = 0 deg —** 0 degree 4 mm Steering wheel set to 0 deg (e.g. automated driving with steer by wire and fixed steering wheel) 5. Stability intervention - RackPositionOffsetFrontAxleTarget = 3 mm 3 Nm 20 degree 7 mm Rack position increased by 3mm (e.g. vehicle stability intervention with steer by wire) 6. Autonomuous Driving - RackPositionFrontAxleTarget = 3 mm —** 0 degree 3 mm Rack position set to 3 mm (e.g. automated driving), offset ignored * Assumption is that driver is holding the steering wheel at the same position as without external request\n** Steering wheel torque depending on driver input. Target request may be ignored if driver is applying torque (driver override).",
    "description": "Introduction In modern vehicles multiple electronic controlled systems are interacting to realize the overall vehicle motion in all physical directions. Typically, the driver gives input e.g. using the steering wheel and the accelerator and brake pedals, but additional vehicle functions may have also requests towards the motion actuators. One example is that a traction control system may want to limit the performance due to slippery road conditions or that the emergency braking system requests braking.",
    "tags": [],
    "title": "Vehicle Motion Management",
    "uri": "/vehicle_signal_specification/catalog/vehicle_motion_management/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Extending and Customizing VSS",
    "content": "VSS defines the standard catalog for vehicle signals independent of the used protocol and environment. In order to adopt the specification we realize that certain additions and modifications to the standard catalog are necessary. VSS Overlays are meant to bring you a standardized way of handling those changes.\nThe following features with the intended usage patterns are currently supported:\nAdding new nodes: By adding nodes the standard catalog can be extended with proprietary concepts. Deleting nodes: Deleting nodes not relevant for the vehicle. Changing the value of existing metadata: The standard catalog defines metadata based on what is assumed to be an average vehicle. Configurations may differ slightly (e.g. the instantiation of number of available seats), or special situations that require a (limited) modification of existing metadata. Adding new key/value pairs as additional metadata: Extending the model with richer information is a fundamental feature enabled by the layer concept. For example, deploying VSS into a specific scenario or with a particular binding/technology often needs some additional information. Multiple layer files: VSS layers can be split into several files in order to clearly separate concerns. Layering allows all the features above to be applied in a composable manner. In order to keep a determinstic result a clear order has to remain. How does it work? Simply said, the tooling accepts, n additional spec files, next to the original specification file, which can overwrite or extend data in the VSS tree defined by the original specification. Before you start you should know:\nOverlay files do not need to be valid specification files by themselves but the merged result counts In practice that means, that nodes in the overlay files (e.g. branches) do not need to specify all the required attributes (like type, description, …) if they are supposed to overwrite certain attributes of an already existing branch in vss. You can omit parent branches if there is no need to change them However, the tooling does not allow implicit branches by design. So if you are creating new branches in overlays they need to be correctly linked to an existing branch in vss. Order matters. The order on how the overlay files are passed in the cli command matters! An example is shown in the figure below. The Figure below illustrates an example of the main specification and two separate overlay files, an example call of the tooling and the resulting tree.\nFigure: Overview on how overlays work within VSS\n# In this overlay all parent branches are included. # If you do not want to change existing branches, it is not necessary to specify them. # Also note that some elements are missing required attributes (description) # but since those elements will be merged with the ones in VSS, the result is valid. Vehicle: type: branch Vehicle.Cabin: type: branch Vehicle.Cabin.NewBranch: #\u003c introduction of a new branch type: branch description: \"new test branch\" Vehicle.Cabin.NewBranch.HasNewSignal: #\u003c introduction of a new signal type: sensor description: \"new test signal\" datatype: int8 Vehicle.Cabin.Door: type: branch Vehicle.Cabin.Door.IsOpen: type: sensor #\u003c change of node type datatype: booleanFile: overlay_1.vspec\n# This overlay would not be valid on its own since `NewBranch` is missing. # When being applied in conjunction with the previous overlay, it would create # `HasNewAttribute` accordingly. Vehicle.Cabin.NewBranch.HasNewAttribute: #\u003c ...with a new attribute type: attribute description: \"new test attribute\" datatype: string Vehicle.Cabin.Door.IsOpen: type: sensor newKey: value #\u003c Add a new key to the node and add a value datatype: booleanFile: overlay_2.vspec\nNode content in Overlays If you are adding a node you need to specify all attributes required for that node type. If you are changing an existing node you typically only need to specify the name and what you would like to overwrite, like in the Vehicle.Speed example below. That also works for overwriting nodes that are created using instances. vss-tools will then look up the node name and merges the attributes.\n# Type and Datatype not needed Vehicle.Speed: unit: m/s # Overwriting the unit of a node created by instances also works Vehicle.Occupant.Row1.DriverSide.HeadPosition.Yaw: unit: mmDeleting nodes It is possible to delete nodes using the delete attribute. You can delete indidvidual signals, branches, instances or a particular signal in a particular instance. A few examples are shown below.\n# Removing IsChildLockActive for DriverSide on Second Row Vehicle.Cabin.Door.Row2.DriverSide.IsChildLockActive: datatype: boolean type: sensor delete: true # Removing Window for all Door instances Vehicle.Cabin.Door.Window: delete: true # Removing Vehicle.Speed Vehicle.Speed: delete: trueWhen using the delete argument vss-tools will print a summary on how many nodes that are removed.\nNodes deleted, given=6, overall=18The number for given represents number of nodes (branches/sensors/actuators/attributes) explicitly removed. The overall number represents total number, including child nodes for explicitly removed branches. More detailed output is given in debug mode.",
    "description": "VSS defines the standard catalog for vehicle signals independent of the used protocol and environment. In order to adopt the specification we realize that certain additions and modifications to the standard catalog are necessary. VSS Overlays are meant to bring you a standardized way of handling those changes.\nThe following features with the intended usage patterns are currently supported:\nAdding new nodes: By adding nodes the standard catalog can be extended with proprietary concepts.",
    "tags": [],
    "title": "VSS Overlay Mechanism",
    "uri": "/vehicle_signal_specification/extensions/overlay/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set \u003e Data Entry",
    "content": "In VSS each data entry (except branches and structs) must specify a datatype. It can be a primitive type, an array of a primitive type or a struct type.\nThis is the default datatype for the given entry. The VSS project typically selects datatype (and unit) so that values are easily understandable by humans, can cover a reasonable range and supports reasonable precision. An example is given below where Vehicle.Speed has been assigned the datatype float and the unit km/h.\nVehicle.Speed: datatype: float type: sensor unit: km/h description: Vehicle speed.The meaning of this is that unless otherwise specified (by an API), the value is supposed to be given as a decimal number with km/h as unit. An example from VISS is given below, showing how the speed 123.45 km/h is returned As \"123.45\".\nHTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 ... { “data”:{“path”:”Vehicle.Speed”, “dp”:{“value”:”123.45”, “ts”:”2020-04-15T13:37:00Z”} } }Another example is the Kuksa Client where values are to be given in the unit and datatype specified by VSS.\nTest Client\u003e setValue Vehicle.Speed 43.2 2024-10-18 16:12:54,307 INFO kuksa_client.grpc.aio: Using v2 OK Test Client\u003e getValue Vehicle.Speed { \"path\": \"Vehicle.Speed\", \"value\": { \"value\": 43.20000076293945, \"timestamp\": \"2024-10-18T14:12:54.314814+00:00\" } }It is not mandatory for an implementation, protocol or an API to use the datatype and unit specified by the COVESA VSS catalog. A VSS entity can in a customized or extended VSS catalog, be annotated with information specifying that the data entry shall be transmitted or stored using a different datatype, possibly involving scaling and offset. An API may in addition or as replacement to the default datatype and offset allow the entity to be read or written using alternative representations or alternative units.\nIt is however recommended that the default method to read or write a dataentry shall be based on the datatype and unit definined in the standard VSS catalog for signals definied in the standard VSS catalog, as there otherwise is a risk that the client and the server interpret the value differently.\nSupported datatypes Name Datatype Min Max uint8 unsigned 8-bit integer 0 255 int8 signed 8-bit integer -128 127 uint16 unsigned 16-bit integer 0 65535 int16 signed 16-bit integer -32768 32767 uint32 unsigned 32-bit integer 0 4294967295 int32 signed 32-bit integer -2147483648 2147483647 uint64 unsigned 64-bit integer 0 2^64 - 1 int64 signed 64-bit integer -2^63 2^63 - 1 boolean boolean value 0/false 1/true float IEEE 754-2008 binary32 floating point number -3.40e 38 3.40e 38 double IEEE 754-2008 binary64 floating point number -1.80e 308 1.80e 308 string character string (unicode) n/a n/a Strings Strings in VSS supports the unicode character set. Actual encoding like UTF-8 or UTF-16 is not specified by VSS, that is to up to the Protocol/API/SDK implementing VSS support to decide.\nArrays Besides the datatypes described above, VSS supports as well the concept of arrays, as a collection of elements based on the data entry definition, wherein it’s specified. By default the size of the array is undefined. By the optional keyword arraysize the size of the array can be specified. The following syntax shall be used to declare an array:\n# Array of datatype uint32, by default size of the array is undefined datatype: uint32[] # Optional: specified number of elements in the array arraysize: 5An example for the usage of arrays is Vehicle.OBD.DTCList which contains a list of Diagnostic Trouble Codes (DTCs) present in a vehicle.\nStructs VSS struct support is further described on this page.\nData Streams Data Entries, which describe sensors offering binary streams (e.g. cameras), are not supported directly by VSS with a dedicated datatype. Instead, they are described through the meta data about the sensor itself and how to retrieve the corresponding data stream.\nA camera can be a good example of it. The Data Entry for the camera and the corresponding video stream could look like:\nCamera: type: branch description: Information about the camera and how to connect to the video stream Camera.IsActive: type: actuator datatype: boolean description: If the camera is active, the client is able to retrieve the video stream Camera.URI: type: sensor datatype: string description: URI for retrieving the video stream, with information on how to access the stream (e.g. protocol, data format, encoding, etc.)In this example, it shows the usage of meta data about the status of the sensor. The camera can be set to active through the same data entry (actuator). A dynamic data entry (sensor) is used for the URI of the video stream. Information on how to access the stream is expected.",
    "description": "In VSS each data entry (except branches and structs) must specify a datatype. It can be a primitive type, an array of a primitive type or a struct type.\nThis is the default datatype for the given entry. The VSS project typically selects datatype (and unit) so that values are easily understandable by humans, can cover a reasonable range and supports reasonable precision. An example is given below where Vehicle.Speed has been assigned the datatype float and the unit km/h.",
    "tags": [],
    "title": "Datatypes",
    "uri": "/vehicle_signal_specification/rule_set/data_entry/data_types/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification",
    "content": "VSS Tree Model The diagram below shows a generated tree of the VSS. Here you can see a mapping for the current catalog of signals related to vehicles. Click a Branch Node to expand or collapse the tree. (Slower animation while pressing the altKey (“option” key for Mac OS-X).)\nCurrent Population of the model - in respect to VSS Types and Datatypes Click on the nodes to highlight the links, or hover over the links to see their exact population.\nReleases and types How the model changed in major releases.",
    "description": "VSS Tree Model The diagram below shows a generated tree of the VSS. Here you can see a mapping for the current catalog of signals related to vehicles. Click a Branch Node to expand or collapse the tree. (Slower animation while pressing the altKey (“option” key for Mac OS-X).)\nCurrent Population of the model - in respect to VSS Types and Datatypes Click on the nodes to highlight the links, or hover over the links to see their exact population.",
    "tags": [],
    "title": "Introduction",
    "uri": "/vehicle_signal_specification/introduction/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Extending and Customizing VSS",
    "content": "This profile can be used to specify how VSS signals can be extended to include cybersecurity attibutes.\nMapping Syntax The syntax for definition of a signal with cybersecurty attributes (in an overlay) is specified below.\n\u003cVSS Signal name\u003e: type: \u003cVSS type\u003e datatype: \u003cVSS datatype\u003e cybersecurity: [authentication: {true|false}] [encryption: {true|false}] [integrity_check: {true|false}] [impact_profiles: {[{motion|privacy|regulation|safety|operational}]}] Set authentication attribute to true if you need to ensure serialized data is being exchanged between trusted entities or prevent unauthorized access to serialized data during transmission. Sample implementation mechanisms are public-key infrastructure, token based authentication etc. Set encryption attribute to true to protect the confidentiality of serialized data or to ensure that even if serialized data is intercepted, it cannot be easily understood or misused. Sample implementation mechanisms are symmetric (e.g AES), asymetric (e.g RSA) or end-to-end encryption. Set integrity_check attribute to detect and prevent unauthorized alterations to serialized data or to maintain the accuracy and reliability of data as it is transmitted or stored. Sample implementation mechanisms are checksums, counters, hash based, message authentication codes etc impact_profiles attribute indicate set of impact profiles that assess potential consequences of security issues. Possible values include: motion: Impact on vehicle movement or control systems. privacy: Impact on the privacy of individuals and data protection. regulation: Impact related to regulatory compliance and legal issues. safety: Impact on personal safety and potential physical harm. operational: Impact on system functionality and service availability. Example Vehicle.Body.Mirrors.DriverSide.Tilt: datatype: int8 type: actuator cybersecurity: authentication: false encryption: false integrity: true impact_profiles: [operational]",
    "description": "This profile can be used to specify how VSS signals can be extended to include cybersecurity attibutes.\nMapping Syntax The syntax for definition of a signal with cybersecurty attributes (in an overlay) is specified below.\n\u003cVSS Signal name\u003e: type: \u003cVSS type\u003e datatype: \u003cVSS datatype\u003e cybersecurity: [authentication: {true|false}] [encryption: {true|false}] [integrity_check: {true|false}] [impact_profiles: {[{motion|privacy|regulation|safety|operational}]}] Set authentication attribute to true if you need to ensure serialized data is being exchanged between trusted entities or prevent unauthorized access to serialized data during transmission.",
    "tags": [],
    "title": "Cybersecurity Profile",
    "uri": "/vehicle_signal_specification/extensions/cybersecurity_profile/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set \u003e Data Entry",
    "content": "Structs are a newly introduced feature to the VSS-syntax. Please note that all VSS-tools exporters do not yet support structs.\nIntroduction VSS has historically supported only the following datatypes:\nInteger-based datatypes (e.g. uint8, int32) Float-based datatypes (float, double) String Boolean In addition to this VSS arrays of the datatypes given above has been supported. This has been considered insufficient for some use-cases. Typical examples are when something cannot be described by a single value, but multiple values are needed.\nA few hypothetical examples include:\nGPS locations, where latitude and longitude must be handled together Obstacles - where each obstacle may contain information like category, probability and location Errors/Warnings - where each item might contain information on category and priority as well as time stamp Based on this a syntax for supporting structs in VSS has been defined\nIntended usage The struct support in VSS is introduced to facilitate logical binding/grouping of data that originates from the same source. It is intended to be used only when it is important that the data is read or written in an atomic operation. It is not intended to be used to specify how data shall be packaged and serialized when transported.\nBy this reason VSS-project will not introduce shorter datatypes (like uint1,uint4) to enable bit-encoding of data. The order of elements in a struct is from a VSS perspective considered as arbitrary. The VSS project will by this reason not publish guidelines on how to order items in the struct to minimize size, and no concept for introducing padding will exist.\nStructs shall be used in VSS standard catalog only when considered to give a significant advantage compared to using only primitive datatypes.\nStructs vs. Aggregate VSS supports a keyword aggregate that can be used on branches to indicate that the branch preferably shall be read and written in atomic operations. The keyword is however currently not used in the standard catalog, and it is not known if any implementation exists that actually consider it. There have been criticism that aggregate changes the semantic meaning of branches and signals, i.e. that a signal is no longer handed as an independent object. The exact meaning of aggregate is furthermore not well defined by VSS. Shall for example a write request (or update of sensor values) be rejected by an implementation if not all signals in the branch are updated in the same operation? Semantic interpretation is also ambiguous if the branch contains a mix of sensors, attributes and actuators. Using structs as datatype is better aligned with the view that VSS signals are independent objects, and the semantic ambiguities related to aggregate are not present for structs.\nAggregate could however be useful as information on deployment level. It gives the possibility to indicate that in this particular deployment the signals in the branch shall be treated as an aggregate. Exact meaning of the aggregate keyword is then deployment specific. With this view, aggregate shall never be used in the standard catalog, but can be used in overlays for deployment-specific purposes.\nGeneral Idea and Basic Semantics A signal of struct datatype shall be defined in the same way as other VSS signals, the only difference would be that instead of using a primitive datatype there shall be a reference to a struct datatype. This means that structs can be used for all types of VSS signals (i.e. sensor, attribute and actuator). If a signal of struct datatype is sent or received, VSS expects all included items to have valid values, i.e. all items are mandatory. For example, if a struct contains the items A, B and C - then it is expected that the sent signal contains value for all items. If some items are considered optional then the value range of the items must be adapted to include values indicating “not available” or “undefined”, or additional items needs to be added to indicate which items that have valid values.\nVSS makes no assumption on how structs are transferred or stored by implementations. It is however expected that they are read and written by atomic operations. This means that the data storage shall be “locked” while the items of the struct are read, preventing changes to happen while reading/writing the items.\nStructs shall be defined in a separate tree intended for definition of datatypes only. This means that signal definitions and struct definitions cannot exist in the same files. Tooling must thus accept one (or more) parameters for specifying datatype definition(s). The tree must have a single branch as root, i.e. it is not possible to have a struct as root.\nCurrently no structs have been introduced to the VSS standard catalog, but it has been agreed that the VSS standard catalog type root shall be called Types, and that types added to VSS standard catalog will be added to the Types.Vehicle branch. For example, if a type for GNSS location would be added to the VSS standard catalog in the future, it may be called Types.Vehicle.GNSSLocationType. User extensions could then be added as sub-branches to Types, like Types.OEM.SomeOEMType.\nThe top level datatypes file(s) (e.g. vss_types.vspec) can refer to other datatype files similar to the top VSS file. It is possible to specify that multiple datatype files shall be used, but all datatypes must belong to the same root. This means if the first file defines A.B, then the seconds file can define A.C, but not X.Y as that would result in two roots (A and X).\nFor current vss-tools support for structs see documentation in the vss-tools repository.\nNaming Restrictions The VSS syntax and tooling shall not enforce any restrictions on naming for the datatype tree. It may even use the same branch structure as the signal tree. This means that it theoretically at the same time could exist both a signal A.B.C and a struct A.B.C. This is not a problem as it always from context is clear whether a name refers to a signal or a datatype.\nSimple Definition and Usage This could be a hypothetical content of a VSS datatype file\nTypes: type: branch Types.DeliveryInfo: type: struct description: A struct datatype containing info for each delivery Types.DeliveryInfo.Address: datatype: string type: property description: Destination address Types.DeliveryInfo.Receiver: datatype: string type: property description: Name of receiverThis struct definition could then be referenced from the VSS signal tree\nDelivery: datatype: Types.DeliveryInfo type: sensorThe datatype file may contain sub-branches and #include-statements just like regular VSS files\nTypes: type: branch Types.Powertrain: type: branch description: Powertrain datatypes. #include Powertrain/Powertrain.vspec Types.PowertrainName resolution Two ways of referring to a datatype are considered correct:\nIn Datatype Tree:\nReference by absolute path Reference by (leaf) name to a struct definition within the same branch In Signal Tree:\nReference by absolute path Relative paths (e.g. ../Powertrain.SomeStruct) are not allowed. Structs in parent branches will not be visible, in those cases absolute path needs to be used instead.\nThe reference by leaf name is applicable only for structs referencing other structs!\nExpectations on VSS implementations (e.g. VISS, KUKSA) It is expected of implementations to support atomic read/write/subscribe of complete signals defined with struct datatype. They may support read of parts of signal, e.g. DeliveryList.Receiver\nArray Support It is allowed to use a struct type in an array\nDeliveryList: datatype: Types.DeliveryInfo[] type: sensor description: List of deliveriesBy default the array has an arbitrary number of element and may be empty. If a fixed size array is wanted the keyword arraysize can be used to specify size:\nDeliveryList: datatype: Types.DeliveryInfo[] arraysize: 5 type: sensor description: List of deliveriesExpectations on VSS implementations (e.g. VISS, KUKSA.val) For array datatypes (like above) VSS implementations may support several mechanisms\nIt is expected that they can support read/write/subscribe of the whole array, i.e. write all or read all in the same request They may optionally support additional operations like Writing/Reading a single instance, e.g. DeliveryList[2] (index mechanism is implementation dependent) Appending/Deleting individual instances Searching for instances with specific conditions. Structure in Structure It is allowed to refer to a structure datatype from within a structure\nOpenHours: type: struct description: A struct datatype containing information on open hours OpenHours.Open: datatype: uint8 type: property max: 24 description: Time the address opens OpenHours.Close: datatype: uint8 type: property max: 24 description: Time the address close DeliveryInfo: type: struct description: A struct datatype containing info for each delivery DeliveryInfo.Address: datatype: string type: property description: Destination address DeliveryInfo.Receiver: datatype: string type: property description: Name of receiver DeliveryInfo.Open: datatype: OpenHours type: property description: When is receiver availableOrder of declaration/definition The order of declaration/definition shall not matter. As signals and datatypes are defined in different trees this is a topic only for struct definitions referring to other struct definitions. A hypothetical example is shown below. An item in the struct DeliveryInfo can refer to the struct OpenHours even if that struct is defined further down in the same file. If using --types \u003cfile\u003e multiple times all files except the first will be treated similar to overlays. This means that is allowed to define A.B.C in multiple files, but then subsequent (re-)definitions will overwrite what has been defined previously. Note that if type files want to use structs from other files that the dependent files are specified first. Therefore the order of given type files matters.\nDeliveryInfo: type: struct description: A struct datatype containing info for each delivery DeliveryInfo.Open: datatype: OpenHours type: property description: When is receiver available OpenHours: type: struct description: A struct datatype containing information on open hoursInline Struct Inline/anonymous structs are not allowed!\nDefault Values VSS supports default values.\nDefault values are also allowed for signals of struct datatype.\nIt is also possible to define default values for properties. If all items of a struct datatype have default values, then a signal (or item) using the struct datatype is also considered to have a default value.\nDefault values are given in Yaml syntax, two examples are given below\nReturnAddress: datatype: Types.DeliveryInfo type: attribute description: Where to send returns default: Address: \"221B Baker Street\" Receiver: \"Sherlock Holmes\" Open: Open: 9 Close: 17ReturnAddresses: datatype: Types.DeliveryInfo[] type: attribute description: Where to send returns default: - Address: \"221B Baker Street\" Receiver: \"Sherlock Holmes\" Open: Open: 9 Close: 17 - Address: \"742 Evergreen Terrace\" Receiver: \"Homer Simpson\" Open: Open: 15 Close: 16As a special case, [] can be used as default value to denote an empty array.\nDeliveryAddresses: datatype: Types.DeliveryInfo[] type: sensors description: List of deliveries default: []It is also possible to use JSON syntax to specify default values for structs.\nAllowed Values VSS supports specification of allowed values.\nUsing allowed for type: property is allowed (if allowed is supported for the used datatype). Using allowed for signals and items of struct datatype or array of struct datatype is allowed.",
    "description": "Structs are a newly introduced feature to the VSS-syntax. Please note that all VSS-tools exporters do not yet support structs.\nIntroduction VSS has historically supported only the following datatypes:\nInteger-based datatypes (e.g. uint8, int32) Float-based datatypes (float, double) String Boolean In addition to this VSS arrays of the datatypes given above has been supported. This has been considered insufficient for some use-cases. Typical examples are when something cannot be described by a single value, but multiple values are needed.",
    "tags": [],
    "title": "Struct Types",
    "uri": "/vehicle_signal_specification/rule_set/data_entry/data_types_struct/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification",
    "content": "The Vehicle Signal Specification (VSS) project is an initiative by COVESA to define a syntax and a catalog for vehicle signals.\nThe artifacts maintained by the VSS project consist of:\nSource code, documentation and releases in the VSS github repository. Tools for parsing and converting VSS files in the VSS-tools github repository. The VSS project has an informal structure with a chair and github maintainers appointed by COVESA. Tasks for the chair includes hosting regular meeting to discuss incoming pull requests and issues, as well as roadmap and release planning.\nContribution process Anyone may propose changes to VSS. It is up to the VSS project to decide if the changes are feasible to include in VSS. The VSS project does not have any developers or maintainers paid by COVESA. Instead, the VSS project relies on voluntary contributions, typically from member organizations. The maintainers are expected to review incoming pull requests. All contributions must follow the COVESA contribution guidelines.\nIn general, pull requests shall be opened for at least a week before being merged to give time for COVESA members to review the pull request and provide comments. In case of larger changes or changes that affect backward compatibility pull requests are typically opened for a longer period, to allow for a through review. Pull requests, unless trivial, are typically merged first after a decision at one of the regular VSS meetings, see link at COVESA VSS wiki page. These rules concerns primarily normative content (see below), non-normative content may be updated without thorough reviews.\nFor more information and guides on how to contribute see CONTRIBUTING.md.\nBranches VSS development is typically developed in the master branch only. Each release is tagged and a maintenance branch is created (e.g. release/3.0) which could be used as target for pull requests intending to patch a release.\nNormative vs. non-normative content The VSS repositories contain some artifacts that can be considered normative, i.e. an implementation claiming to “support” VSS shall:\nSupport signals defined according to the rules in the VSS documentation (source, generated) Support the signals currently defined in VSS. The signals in source format (*.vspec files) can be found in Github repository. Derived formats supported by VSS project are included in each release, originating from the tools in the VSS-tools github repository. In addition to this the VSS repositores contain artifacts that currently are considered non-normative. This includes immature concepts and work-in progress. Non-normative content include:\nVSS Github Wiki VSS Tools Wiki Overlays and Profiles Contributed tools The list of what is considered normative and non-normative is no static, it may change over time.\nHandling of backward compatibility The VSS project aims to keep backward compatibility as far as feasible. VSS is however an evolving syntax and catalog and there are still areas where changes are need to fit the need of users. Changes that breaks backward compatibility are typically introduced only in major releases (e.g. X.0) and shall be documented in release notes. This concerns changes to syntax and signals, but also to tools.\nChanges considered as backward incompatible include:\nSignals have been deleted, renamed or change of datatype or unit. New data entry attributes have been added to standard VSS catalog, only accepted by an updated VSS-tools version. VSS-tools CLI changed, for example arguments renamed or new mandatory arguments added. Columns/fields removed from VSS-tools exporter output. Changes NOT considered as backward incompatible include:\nNew signals, units or quanties added to VSS standard catalog. New VSS-tools exporters added. Columns/fields added to VSS-tools exporter output. The VSS project has introduced a deprecation concept. If possible, when e.g. renaming or moving a signal or changing tools the old signal or parameter set shall be kept but marked as deprecated. That allows the change to be introduced in a minor version (e.g. X.Y). The old signal shall be removed first in the next major release, or later if needed.\nA history of past changes and planned changes that affects backward compatibility can be found in the Changelog.\nRelease Process The release process is further described in the Github repository.",
    "description": "The Vehicle Signal Specification (VSS) project is an initiative by COVESA to define a syntax and a catalog for vehicle signals.\nThe artifacts maintained by the VSS project consist of:\nSource code, documentation and releases in the VSS github repository. Tools for parsing and converting VSS files in the VSS-tools github repository. The VSS project has an informal structure with a chair and github maintainers appointed by COVESA. Tasks for the chair includes hosting regular meeting to discuss incoming pull requests and issues, as well as roadmap and release planning.",
    "tags": [],
    "title": "Governance",
    "uri": "/vehicle_signal_specification/governance/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification",
    "content": "The Rule Set of a domain taxonomy is used to describe how to write the data definition syntactically.\nThis chapter defines and describes the rule set for VSS. Tools in the vss-tools repository can be used to validate that a specification follows the rule set for VSS, but those tools may have limitations and may not check all rules stated in this document. In case of conflict, what is stated in the rule set in this documentation is considered to have precedence over tool implementations.\nVersion handling The source for the rule set is in VSS Git repository. The online version of the rule set in the generated VSS documentation is updated whenever a new commit is merged to the VSS master branch and does this not necessarily correspond to the rule set for the last release VSS version.\nTo highlight important changes to the VSS rule set two notations are used in the documen\nsince version X.Y means that the concept/syntax was introduced in version X.Y. Older tools not supporting VSS version X.Y may not support this concept/syntax. deprecated since version X.Y means that the concept/syntax is no longer recommended from version X.Y onwards. The concept/syntax may be removed in the next major release. ",
    "description": "The Rule Set of a domain taxonomy is used to describe how to write the data definition syntactically.\nThis chapter defines and describes the rule set for VSS. Tools in the vss-tools repository can be used to validate that a specification follows the rule set for VSS, but those tools may have limitations and may not check all rules stated in this document. In case of conflict, what is stated in the rule set in this documentation is considered to have precedence over tool implementations.",
    "tags": [],
    "title": "Rule Set",
    "uri": "/vehicle_signal_specification/rule_set/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set \u003e Data Entry",
    "content": "Introduction to Data Units in VSS It is in VSS possible for signals to specify a unit of measurement from a list of predefined data units. For most signals in the VSS standard catalog, a data unit has been selected. A typical example is Vehicle.Speed, as shown below.\nVehicle.Speed: datatype: float type: sensor unit: km/h description: Vehicle speed.The ambition when selecting data unit for signals in VSS standard catalog has been to use either a unit based on SI-units, or a unit commonly used within the vehicle industry. For the Vehicle.Speed example above this means that km/h has been selected, even if m/s from an SI-perspective would have been a better choice.\nIt must be noted that the selected unit does not imply that the value of Vehicle.Speed always needs to be sent or visualized as km/h (with float as datatype). A user interface or API may show or request vehicle speed in any unit it likes, and a transport protocol may send speed in another unit, possibly also involving scaling and offset. But in protocols not explicitly specifying data units (like VISS) it is expected that Vehicle.Speed is sent and received as km/h (without scaling or offset). However since units define possible allowed-datatypes the given datatype has to match the allowed ones.\nVSS does not offer any syntax for defining alternative units for a specific signal. The VSS project has specified for all units a corresponding quantity e.g. velocity for km/h. An API may use the quantity information to identify alternative units that can be used to represent the signal. The VSS list of units does not specify conversion factors, so even if VSS list both km/h and m/s as units for the quantity velocity, it is not specified how they relate to each other.\nIn some cases it is natural to omit the data unit. This concerns typically signals where datatype string is used, but also signals where the value just represents a number (dimensionless quantities), like in the example below:\nVehicle.Cabin.DoorCount: datatype: uint8 type: attribute default: 4 description: Number of doors in vehicle.Logical Data Units VSS supports percent as data unit, typically with 0 to 100% as the allowed range. In some cases, the definition on how to calculate the signal value is obvious, like for Vehicle.Powertrain.FuelSystem.Level below. It is likely that all VSS users will calculate fuel level in the same way, i.e. the meaning of a fuel level of 50% is well agreed, the liters of fuel in the tank is exactly 50% of nominal capacity.\nVehicle.Powertrain.FuelSystem.Level: datatype: uint8 type: sensor unit: percent min: 0 max: 100 description: Level in fuel tank as percent of capacity. 0 = empty. 100 = full.In other cases, the formula for calculating the signal is not obvious and is not specified in VSS. A typical example is shown below for clutch wear. While most VSS users likely can agree that a brand new clutch shall have 0 as “ClutchWear”, the exact formula for calculating clutch wear for a used clutch will likely be vehicle specific. Some vehicles might monitor actual wear, others might estimate it based on vehicle usage. This is in VSS called a logical range, a VSS user knows what range to use but are free to define the formula for calculating the value. Values from different vehicles (of different make/model) can not always be compared, as the formula used for calculation may differ.\nVehicle.Powertrain.Transmission.ClutchWear: datatype: uint8 type: sensor unit: percent max: 100 description: Clutch wear as percent. 0 = no wear. 100 = worn.Supported Data Units in VSS Standard Catalog The VSS syntax does not in itself specify what units can be used, the unit attribute as declared for signals in *.vspec files is optional and can contain an arbitrary string value. VSS-Tools however require that all units used are defined and therefore is also a requirement for signals in the VSS standard catalog. Units are defined by including them in a unit file with syntax as described below. One or more unit files can be specified by the -u parameter and, if not given, the tools search for a file units.yaml in the same directory as the root *.vspec file.\nFor the VSS standard catalog the VSS-project has defined a set of units that can be used for signals in the VSS standard catalog. This list is composed of definitions according to International Units (SI) and few automotive-specific units: Specification, Wikipedia. It can be noted that not all units in the list are currently used by the VSS standard catalog, but they may be used in the future or may be used for customization of the VSS catalog.\nThe VSS list of units for the standard catalog exists in units.yaml.\nAddition of new Data Units to VSS standard catalog The list of units in VSS standard catalog is not static. New units can be added if needed for signals in the VSS standard catalog, or if the VSS-project considers that the unit might be useful for customization of the VSS tree. If you would like to propose a new unit to be added to the list please create a pull request where the new unit is added to units.yaml.\nIf the unit is needed for a new signal in the VSS standard catalog you can propose the new signal and the new unit in the same Pull Request.\nUnit file syntax Unit files follow the syntax defined below:\n[ \u003cvss-unit-identifier\u003e: # Typically unit abbreviation, like km/h or mm, but no special characters definition: \u003cstring\u003e [unit: \u003cstring\u003e] # Full name of unit, optional, if not given assumed to be equal to vss-unit-identifier quantity: \u003cstring\u003e # Quantity of the unit. [allowed-datatypes] : ['numeric', 'string', uint8', ...]] # Allowed datatypes in VSS standard catalog [deprecation: \u003creason\u003e] ]*The VSS term quantity corresponds roughly to the term quantity as defined in for example ISO 80000. Typical example are length, mass and velocity that all can be expressed in SI-units. However, from a VSS perspective quantities do not need to correspond to physical quantities. It could be an arbitrary term, but it is generally expected that it is possible to convert between values using different units but defined with the same quantity.\nExample:\nm: definition: Length measured in meters unit: meter quantity: length allowed-datatypes: ['numeric'] mm: definition: Length measured in millimeters unit: millimeter quantity: length allowed-datatypes: ['numeric']As m and mm are defined with the same quantity it is expected that you can convert a value from m to mm.\nThe allowed-datatypes attributes can be used to specify which VSS datatypes can contain values of a particular unit. For most units the symbolic datatype numeric meaning any float or integer datatype can be used. As an example, both uint8 and float can be used to represent a length value. If using uint8 you will have range restrictions, but that might be acceptable for some signals. For some units more specific datatype restrictions are relevant. Some examples:\nA date/time expressed in ISO 8061 format (unit: iso8601) can only be represented as a string A UNIX Timestamp signal (unit: unix-time) must be at least 32 bit unsigned to be able to handle date/time after year 2038. The deprecation keyword can be used to indicate that a specific unit may be removed in the future. Tooling shall preferably give a warning if a signal uses a deprecated unit or the unit used belongs to a deprecated quantity. The reason should preferably list when and why the unit is deprecated, a hypothetical example is given below:\ninch: definition: Distance measured in inches unit: inch quantity: distance deprecation: V5.0 replaced by 'in' in: definition: Distance measured in inches unit: inch quantity: distanceQuantity file syntax Defining of quantities is required. If tooling supports quantity files it can verify that all units provided in unit files use defined quantities. For the VSS standard catalog it is required that matching quantities have been defined for all units.\n[ \u003cvss-quantity-identifier\u003e: # Identifier preferably taken from a standard, like ISO 80000 definition: \u003cstring\u003e [remark: \u003cstring\u003e] # remark as defined in for example ISO 80000 [comment: \u003cstring\u003e] [deprecation: \u003creason\u003e] ]*The VSS list of quantities for the standard catalog exists in quantities.yaml.\nAddition of new Quantities to VSS standard catalog The list of quantities in VSS standard catalog is not static. New quantities can be added if needed for units in the VSS standard catalog, or if the VSS-project considers that the quantity might be useful for custom units. If you would like to propose a new quantity to be added to the list please create a pull request.\nIf the quantity is needed for a new unit in the VSS standard catalog you can propose the new quantity and the new unit in the same Pull Request.\nDefining custom units It is possible to define custom units in a unit file. Assume for instance you want to have a signal showing remaining range in furlong. Then you could add an additional unit furlong. No need to specify unit or symbol as they equals the default (i.e. “furlong”). As this unit is not commonly used and not described in any standards, it might be relevant to describe how it can be converted to other units. That is however only informative, as it a custom unit a downstream implementation supporting unit conversion may not support automatic conversion of furlong to other units.\nunits: furlong: definition: Length measured in furlong, 1 furlong equals 201.1680 m quantity: length allowed-datatypes: ['numeric']",
    "description": "Introduction to Data Units in VSS It is in VSS possible for signals to specify a unit of measurement from a list of predefined data units. For most signals in the VSS standard catalog, a data unit has been selected. A typical example is Vehicle.Speed, as shown below.\nVehicle.Speed: datatype: float type: sensor unit: km/h description: Vehicle speed.The ambition when selecting data unit for signals in VSS standard catalog has been to use either a unit based on SI-units, or a unit commonly used within the vehicle industry.",
    "tags": [],
    "title": "Data Units",
    "uri": "/vehicle_signal_specification/rule_set/data_entry/data_units/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Extending and Customizing VSS",
    "content": "This profile can be used to specify how VSS signals can be serialized on network as data signal.\nMapping Syntax The syntax for definition of a signal with network serialization data (in an overlay) is specified below.\n\u003cVSS Signal name\u003e: type: \u003cVSS type\u003e datatype: \u003cVSS datatype\u003e network_serialization: signal: \u003csignal name in DBC or ARXML\u003e [interval_ms: \u003c data update interval in milliseconds\u003e] [on_change: {true|false}] [endianness: {big_endian|little_endian}] [default: \u003cdefault value or init value (physical) of the signal\u003e] [length_bits: \u003c length of signal in bits\u003e] [transform: ...]Specifying network signal name is mandatory. It may or maynot be same as VSS signal name but it must correspond to a signal defined in DBC or ARXML.\nThe interval_ms value indicates the (minimum) interval between updates in milliseconds. A value of 1000 indicates that the VSS system wants at least 1000 milliseconds between each update. The on_change attribute specifies that the VSS signal only shall be sent if the value has changed. If both interval_ms and on_change are given it shall be considered as an AND-criteria. An update will be sent if the value has changed and the given interval has passed. If none of interval_ms and on_change are specified it corresponds to that the signal shall be sent as soon as value has changed, i.e. on_change: true. The endianness attribute shall be set to represent the order in which bytes are arraged. The default indicates the default value of signal in same units as min and max of VSS signal. The length_bits represents length of signal in bits. However, this could be auto-calculated if transformation transformation is provided. The transform entry can be used to specify math or representation of signal i.e conversion between physical to internal and/or textual represenation of signal values. If transform is not specified values will be transformed as is. This is applicable for signal representing enumerations. Transformation Math Transformation A Math transformation can be defined by the math attribute. It accepts py-expression-eval formulas as attribute. It is expected that the “from” value is represented as x.\nWhen evaluating what transformation is needed one must study both the network signal and the VSS signal. An example is given below for mirror tilt of left mirror.\nNetwork Signal\nThe signal VCLEFT_mirrorTiltYPosition provides mirror tilt.\nSG_ VCLEFT_mirrorTiltYPosition : 41|8@1+ (0.02,0) [0|5] \"V\" ReceiverAn introduction to DBC file syntax can be found here. The specification above shows that on CAN the tilt is represented as 0-5 Volts. The value is sent with a scaling of 0.02 and uses 8 bits, i.e. 5 Volts is transmitted as 250, but that information is not needed when using the profile, as the transformation defined in the DBC is performed automatically when CAN frames are read. For the input to the mapping you will need to consider just a value between 0 and 5 V in this example. VSS The corresponding signal in VSS uses -100 percent to +100 percent as range and int8 as datatype:\nVehicle.Body.Mirrors.DriverSide.Tilt: datatype: int8 unit: percent min: -100 max: 100 type: actuator description: Mirror tilt as a percent. 0 = Center Position. 100 = Fully Upward Position. -100 = Fully Downward Position.With an assumptions that 5 Volts corresponds to fully upward (+100%) and 0 Volts corresponds to fully downward (-100%) then one could define mapping like in the example below.\nVehicle.Body.Mirrors.DriverSide.Tilt: datatype: int8 type: actuator network_serialization: signal: VCLEFT_mirrorTiltYPosition interval_ms: 100 transform: math: \"floor((x*40)-100)\"I.e. 2 Volts corresponds to (2*40)-100 = -20%.\nRepresenation Transformation A representation transformation can be specified with the representation attribute. It must consist of a list of value/text pairs like in the example below. When a network signal value is received the feeder will look for a matching value value in the list, and the corresponding text value will be sent to KUKSA.val.\nVehicle.Powertrain.Transmission.CurrentGear: type: sensor datatype: int8 network_serialization: signal: DI_gear transform: representation: - text: DI_GEAR_D value: 1 - text: DI_GEAR_P value: 0 - text: DI_GEAR_INVALID value: 0 - text: DI_GEAR_R value: -1Numerical values must be written without quotes. For boolean signals true and false without quotes is recommended, as that is valid values in both Yaml and JSON. If using Yaml (*.vspec) as source format quoting string values is optional. Quotes may however be needed if the value otherwise could be misinterpreted as a Yaml 1.1 literal. Typical examples are values like yes which is a considered as a synonym to true. If using JSON all strings must be quoted.\nExample with math and representation attributes in transform\nVehicle.Body.Mirrors.DriverSide.Tilt: datatype: int8 type: actuator network_serialization: signal: VCLEFT_mirrorTiltYPosition interval_ms: 100 transform: math: \"floor((x*40)-100)\" representation: - value: 255 text: Invalid - value: 254 text: ActuationFailed",
    "description": "This profile can be used to specify how VSS signals can be serialized on network as data signal.\nMapping Syntax The syntax for definition of a signal with network serialization data (in an overlay) is specified below.\n\u003cVSS Signal name\u003e: type: \u003cVSS type\u003e datatype: \u003cVSS datatype\u003e network_serialization: signal: \u003csignal name in DBC or ARXML\u003e [interval_ms: \u003c data update interval in milliseconds\u003e] [on_change: {true|false}] [endianness: {big_endian|little_endian}] [default: \u003cdefault value or init value (physical) of the signal\u003e] [length_bits: \u003c length of signal in bits\u003e] [transform: .",
    "tags": [],
    "title": "Network Serialization Profile",
    "uri": "/vehicle_signal_specification/extensions/network_serialization_profile/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification",
    "content": "The source for the COVESA VSS Catalog can be found in *.vspec files in the COVESA VSS Repository. Released versions of the catalog in various formats can be found at release artifacts.\nEach signal in the VSS catalog has a description field and they may have a comment field. In some cases that is not sufficient to explain the rationale for the signal and how it is intended to be used. This section of the VSS documentation gives additional information on selected signal.\nVSS Catalog Concepts Vehicle Motion Management Information on the VSS concept for motion management. ",
    "description": "The source for the COVESA VSS Catalog can be found in *.vspec files in the COVESA VSS Repository. Released versions of the catalog in various formats can be found at release artifacts.\nEach signal in the VSS catalog has a description field and they may have a comment field. In some cases that is not sufficient to explain the rationale for the signal and how it is intended to be used.",
    "tags": [],
    "title": "VSS Catalog",
    "uri": "/vehicle_signal_specification/catalog/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification",
    "content": "The VSS-project is active in three areas:\nDefining a metamodel (syntax) for VSS datapoints. Defining the VSS Standard Catalog. Implementation of tooling (VSS-Tools). The VSS Standard Catalog defines a common view of the major attributes, sensors and actuators of vehicles. This is used in many different scenarios, protocols and environments. Additional meta data might be required for data-governance, -quality or -sources. The instantiation of branches might not fit your vehicle. Some signals in the VSS Signal Catalog may not be relevant or appropriate for your use-case, and proprietary signals might be needed for extending the specification for your own use-cases\nGeneral methods for extending and customizing VSS Correct use of those attributes are checked by VSS-Tools. It is allowed to use additional attributes to define additional characteristics of VSS datapoints. This could for example be useful for defining deployment-related data, like information on how a datapoint shall be stored or transmitted.\nA simple example could be:\nVehicle.Speed: type: sensor unit: \"km/h\" datatype: float interval_ms: 1000 source: \"ecu0xAA\"… to define source and update interval of the VSS Vehicle.Speed datapoint for a specific deployment. VSS-Tools has a mechanism to consider provided extra attributes.\nThe VSS-project defines the VSS Signal Catalog. It is possible that you need to adapt the content of the catalog for your deployment, by adding, removing or changing signals.\nAs a VSS user you have in principle three methods for extending or customizing VSS\nYou can select to not use the VSS Standard Catalog, and instead use a catalog that you have defined yourself. You can use a fork of the VSS repository and modify the contents as needed. You can use the VSS overlay mechanism to define changes to be applied on top of the VSS Standard Catalog The advantage with the third alternative compared to the second alternative is that it can give a separation between the basic model and deployment information, and reduced risk for merge conflicts if upgrading to a new version of the VSS Standard Catalog.\nExtentions for extending VSS Signal Catalog with additional signals With the feature of overlays, we introduced a new folder in the repository called overlays. In there you’ll find two additional folders with overlays:\nprofiles: Vehicle profiles are larger overlays to adapt VSS to a specific vehicle category, like motorbikes. extensions: VSS Signal Catalog Extensions are smaller overlays typically to be applied after applying vehicle profiles (if any). Warning DISCLAIMER: The overlays in those folders shall currently be seen as examples only, and are not part of the official VSS specification.\nVSS Model Profiles Users of VSS often need the same type of additional data, and for that reason it has been decided that the COVESA VSS-project will maintain a list of extension profiles. A VSS Model Profile describes how VSS extended attributes can be used to provide additional information in a specific area to VSS datapoints. Potential examples could include network serialization, security attributes and safety attributes. They shall as of today not be seen as “standardized profiles” or “recommended profiles”.\nThe extension profiles may be defined within the VSS repository or somewhere else. Extension profiles defined within the VSS repository are managed like all other assets within the repository, i.e. if someone want to contribute or change an extension profile they will need to create a Pull Request which then will be discussed within the project.\nThis information typically does not fit in the standard catalog, but could be provided in a use-case specific overlay.\nExisting VSS Model Profiles Eclipse Kuksa VSS-DBC mapping Cybersecurity Profile Network Serialization Profile ",
    "description": "The VSS-project is active in three areas:\nDefining a metamodel (syntax) for VSS datapoints. Defining the VSS Standard Catalog. Implementation of tooling (VSS-Tools). The VSS Standard Catalog defines a common view of the major attributes, sensors and actuators of vehicles. This is used in many different scenarios, protocols and environments. Additional meta data might be required for data-governance, -quality or -sources. The instantiation of branches might not fit your vehicle. Some signals in the VSS Signal Catalog may not be relevant or appropriate for your use-case, and proprietary signals might be needed for extending the specification for your own use-cases",
    "tags": [],
    "title": "Extending and Customizing VSS",
    "uri": "/vehicle_signal_specification/extensions/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set \u003e Data Entry",
    "content": "Property Types Overview sensor type Sensors are properties that, from a VSS-perspective, are read-only. The values of a sensor property typically change over time and within an ignition cycle (i.e., a driving journey). Reading a sensor shall return the actual value of the related property (e.g., the current speed or the current position of the seat).\nactuator type Similarly, actuators are properties that, from a VSS-perspective, can be read and written. Actuators in VSS can be used to represent both the actual value (i.e., read) and the desired value of a property (i.e., write). The value written to a property that involves a slow mechanical action or certain motion might not be immediately reflected in a read operation if the property value is read immediately after a write operation. Some properties like Window.Position or Seat.Position are clear examples of things that might not change instantly. Hence, the written value (i.e., the desired target) and actual value may differ. Unless otherwise specified it is assumed that APIs implementing access to VSS data shall return actual value for read/subscribe-operations, and update the desired value for write-operations.\nA typical example could be if someone wants to change the position of a seat from 0 to 100. This can be changed by setting the corresponding actuator to 100. If the actuator is read directly after the set request it will still return 0 as it might take some seconds before the seat reaches the wanted position of 100. If the seat by some reason is blocked or cannot be moved due to safety reasons it might never reach the wanted position. It is up to the vehicle to decide how long time it shall try to reach the desired value and what to do if it needs to give up.\nattribute type Attributes are properties whose values do not change within an ignition cycle (i.e., a driving journey). In other words, characteristics that are often static. For example, the color and model of a car. If a default value has not been specified, then the user of the specification must define the associated value matching the actual vehicle. For example, the specification might have the attribute Brand without a default value associated. Then, the user of the specification is responsible to assign Some example brand as the value for that attribute. If the standard defines a default value but it does not fit the actual vehicle, then the OEM must override the standard default value.\nAttribute values can also change, similar to sensor values. The latter can be useful for attribute values that are likely to change during the lifetime of the vehicle. However, attribute values should typically not change more than once per ignition cycle, or else it should be defined as a sensor instead.\nData Entry A data entry for a signal defines its members. A data entry example is given below:\nVehicle.Speed: type: sensor datatype: float unit: km/h description: Vehicle speed.Each data entry has a name, in the example above Vehicle.Speed. VSS use a dot-notated name style where the full path of a data entry consists of all parent branches from the root node separated by dots and at the end the name of the data entry itself. In the standard VSS catalog the root node is called Vehicle.\nWhen using *.vspec files to define a VSS catalog it is not necessary to give the full dot-notated name for each data-entry, as the *.vspec format supports includes that can be used to append entries to a specific branch.\nIn addition to sensor, actuatorand attribute VSS also supports entries to describe struct data types. The information on data entry attributes below is partially valid also for structs.\nMandatory Data Entry Attributes This is the list of attributes that must be specified for every data entry.\nAttribute Description Comment type Defines the type of the node. This can be branch, sensor, actuator or attribute. datatype Specifies the scalar type of the data entry value. See datatype chapter for a list of available datatypes. Shall not be used for branch entries. description Describes the meaning and content of the signal. The descriptionshall together with other members like datatype and unit provide sufficient information to understand what the signal contains and how signal values shall be constructed or interpreted. Recommended to start with a capital letter and end with a dot (.). Optional Data Entry Attributes In additon to the mandatory attributes some optional attributes have been defined. There may be additional constraints on their usage not specified in the table below.\nAttribute Description Comment comment A comment can be used to provide additional informal information on a signal. This could include background information on the rationale for the signal design, references to related signals, standards and similar. Recommended to start with a capital letter and end with a dot (.). since version 3.0 min The minimum value, within the interval of the given datatype, that the data entry can be assigned. If omitted, the minimum value will be the “Min” value for the given datatype. Cannot be specified if allowed is defined for the same data entry. max The maximum value, within the interval of the given datatype, that the data entry can be assigned. If omitted, the maximum value will be the “Max” value for the given datatype. Cannot be specified if allowed is defined for the same data entry. unit The unit of measurement that the data entry has. See Data Units chapter for a list of available units. Cannot be specified if allowed is defined for the same data entry. pattern Can be used for datatype string and string[] to specify a regular expression that limits allowed values for the data entry. The expression must be supported by Python Regular Expressions since version 6.0 default Default value for the data entry. See Default Values. allowed Allowed values for the data entry. See Allowed Values. arraysize If the datatypeis an array, this atrribute can be used to specify the size of the array. See datatype ",
    "description": "Property Types Overview sensor type Sensors are properties that, from a VSS-perspective, are read-only. The values of a sensor property typically change over time and within an ignition cycle (i.e., a driving journey). Reading a sensor shall return the actual value of the related property (e.g., the current speed or the current position of the seat).\nactuator type Similarly, actuators are properties that, from a VSS-perspective, can be read and written.",
    "tags": [],
    "title": "Sensors, Actuators and Attributes",
    "uri": "/vehicle_signal_specification/rule_set/data_entry/sensor_actuator/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification",
    "content": " Warning DISCLAIMER: The following information about open source licensing shall not be considered legal advice. For advice on licensing, COVESA suggests that you contact your open source officer or legal counsel.\nWhich license applies VSS as well as the VSS-tools are covered by the Mozilla Public License 2.0 (MPL-2.0). The MPL-2.0 is an OSI approved Open Source license that gives you a lot of freedom using VSS in your products, or for (academic) research. It also provides a solid legal framework if you choose to contribute to either the standards or the tools.\nWe will line out some answers to commonly asked questions, but keep in mind this page is informational. The legally binding clauses can be found in the license itself. If in doubt, consult your friendly neighborhood lawyer or IP department.\nCan I use VSS / VSS-tools in my commercial products Most definitely yes. You must inform your users that the product contains MPLed code and need to provide access to the source (e.g. by linking to this documentation or our Github repository).\nI modified VSS-tools, do I need to give away my source? If you use the code internally within your organisation (company), you have no obligations to do so. (see also Q5 here). If you distribute the modified vss-tools outside your organization (e.g. to your customers), you need to make the source code of the MPL-2.0 licensed parts available. However, the MPL has only a very weak copyleft effect. As a rule of thumb: You have no obligation to provide code in new files. You have the obligation to make code of changed existing MPLed files available under the clauses of the MPL-2.0, if you distribute them in source or compiled form outside your organisation ((see also Q9,10,11 here)).\nIn any case we do recommend you to consider sharing generally useful improvements with the community. Not only will you win karma points with the community and gain visibility as an innovation leader in the automotive industry, you will most likely also get more robust software as you will have more users and testers.\nI changed VSS or added custom signals to the standard catalog. Do I need to give them away? No. One important selling point of VSS is, that you can always extend the standard catalog with your own use case specific signals. There is no obligation to release any added signals or proprietary information to third parties.\nFrom an MPL-2.0 point of view the information of the previous question applies. To be extra sure, put any additions in separate files, and use the layering approach to modify the standard catalog. This community does not consider deleting elements from the standard catalog or adding VSS #include statements “modifications” in the sense of clause 1.10 of the MPL-2.0.\nAs with the tools, we do recommend you to consider sharing generally useful standard catalog improvements with the community.",
    "description": "Warning DISCLAIMER: The following information about open source licensing shall not be considered legal advice. For advice on licensing, COVESA suggests that you contact your open source officer or legal counsel.\nWhich license applies VSS as well as the VSS-tools are covered by the Mozilla Public License 2.0 (MPL-2.0). The MPL-2.0 is an OSI approved Open Source license that gives you a lot of freedom using VSS in your products, or for (academic) research.",
    "tags": [],
    "title": "License",
    "uri": "/vehicle_signal_specification/license/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification",
    "content": "VSS is used in different products, solutions and use cases. This section will give some pointers to the wider VSS ecosystem",
    "description": "VSS is used in different products, solutions and use cases. This section will give some pointers to the wider VSS ecosystem",
    "tags": [],
    "title": "Ecosystem",
    "uri": "/vehicle_signal_specification/ecosystem/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set \u003e Data Entry",
    "content": "VSS supports default values by the default attribute. The intention is to provide a mechanism to provide initial values for data entries already when loading a VSS catalog. This could typically be useful for attributes that never or rarely change, like vehicle VIN or vehicle color.\nThe standard Vehicle Signal Specification does not include default values for all attributes. If a default value has not been specified then the OEM must define a default value matching the actual vehicle, either by using the default concept, or by the same other mechanism. If the standard defines a default value but it does not fit the actual vehicle, then the OEM must override the standard default value.\nAttribute values can also change, similar to sensor values. The latter can be useful for attribute values that are likely to change during the lifetime of the vehicle. However, attribute values should typically not change more than once per ignition cycle, or else it should be defined as a sensor instead.\nBelow is an example of a complete attribute describing engine power\nMaxPower: datatype: uint16 type: attribute default: 0 unit: kW description: Peak power, in kilowatts, that engine can generate.It is possible to give default values also for arrays. In this case square brackets shall be used. The value for each element in the array shall be specified. The size of the array is given by the number of elements specified within the square brackets.\nExample 1: Empty Array\ndefault: []Example 2: Array with 3 elements, first element has value 1, second element value 2, third element value 0\ndefault: [1, 2, 0]Full example, array with two elements, first with value2, second with value 3:\nSeatPosCount: datatype: uint8[] type: attribute default: [2, 3] description: Number of seats across each row from the front to the rearDefault values can also be defined for structs.",
    "description": "VSS supports default values by the default attribute. The intention is to provide a mechanism to provide initial values for data entries already when loading a VSS catalog. This could typically be useful for attributes that never or rarely change, like vehicle VIN or vehicle color.\nThe standard Vehicle Signal Specification does not include default values for all attributes. If a default value has not been specified then the OEM must define a default value matching the actual vehicle, either by using the default concept, or by the same other mechanism.",
    "tags": [],
    "title": "Default Values",
    "uri": "/vehicle_signal_specification/rule_set/data_entry/default/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set \u003e Data Entry",
    "content": "Specifying allowed values Optionally it is possible to define an array of allowed values, which will restrict the usage of the data entry in the implementation of the specification. It is expected, that any value not mentioned in the array is considered an error and the implementation of the specification shall react accordingly. The datatype of the array elements is the datatype defined for the data entry itself. For attributes it is possible to optionally set a default value.\nSteeringWheel.Position: datatype: string type: attribute default: 'FRONT_LEFT' allowed: ['FRONT_LEFT', 'FRONT_RIGHT'] description: Position of the steering wheel on the left or right side of the vehicle.If allowed is set, min or max cannot be defined.\nThe allowed element is an array of values, all of which must be specified in a list. Only values can be assigned to the data entry, which are specified in this list.\nThe datatype specifier gives the datatype of the individual elements of the allowed list. In general allowed: is valid for all datatypes, including integer- and float-based datatypes, unless otherwise specified.\nRecommendation on String values String values used for default and allowed statements may contain characters from the printable subset of the Unicode character set. If using COVESA VSS-tools it is recommended to use single quotes (') around values as tooling otherwise might handle literals like OFF as boolean values with unexpected result. It is recommended not to specify a dedicated value corresponding to “unknown” or “undefined” unless there is a relevant use-case for that particular signal. The background is that a signal with an array of allowed values shall be handled just as any other signal. If e.g. the value of current speed or vehicle weight is unknown, then the vehicle shall not publish the corresponding signal. Similarly, for the example above, if the steering wheel position is unknown then SteeringWheel.Position shall not be published.\nAllowed values for array datatypes The allowed keyword can also be used for signals of array datatype. In that case, allowed specifies the only valid values for array elements. The actual value of the signal is expected to contain a subset of the values specified in allowed.\nExample:\nDogBreeds: datatype: string[] type: attribute allowed: ['AKITA', 'BOXER', 'DACHSHUND', 'PAPILLON', 'PUG', 'VIZSLA'] description: Brief list of dog breeds.Examples of valid arrays:\n[] # Empty array ['BOXER'] ['PAPILLON', 'VIZSLA', 'BOXER', 'AKITA', 'DACHSHUND'] ['PUG', 'PUG'] # duplication is allowedExample of an invalid array:\n['PAPILLON', 'VIZSLA', 'LOBSTER'] # LOBSTER is not in the allowed value listAllowed for struct datatypes Please see struct documentation.",
    "description": "Specifying allowed values Optionally it is possible to define an array of allowed values, which will restrict the usage of the data entry in the implementation of the specification. It is expected, that any value not mentioned in the array is considered an error and the implementation of the specification shall react accordingly. The datatype of the array elements is the datatype defined for the data entry itself. For attributes it is possible to optionally set a default value.",
    "tags": [],
    "title": "Value Restrictions",
    "uri": "/vehicle_signal_specification/rule_set/data_entry/allowed/index.html"
  },
  {
    "breadcrumb": "",
    "content": "The Vehicle Signal Specification (VSS) is an initiative by COVESA to define a syntax and a catalog for vehicle signals. The source code and releases can be found in the VSS github repository. Some tools for parsing and converting VSS files can be found in the VSS-tools github repository.\nThis documentation gives you an overview of VSS:\nIntroduction Read this part if you want to know more about what the specification is all about, what’s in and out and how to quickly browse through the current status. Governance Introduction to VSS governance model and change log. Rule Set Get familiar with the rule set behind the specification, the structure, the format and concepts. VSS Catalog Information on content and design decisions related to the VSS catalog. Extending and Customizing VSS How can you extend and customize the VSS Catalog for use in your environment. License Information on the VSS license. Ecosystem How to use the specification? Check out the existing tools and standards to transform or make use of VSS. ",
    "description": "The Vehicle Signal Specification (VSS) is an initiative by COVESA to define a syntax and a catalog for vehicle signals. The source code and releases can be found in the VSS github repository. Some tools for parsing and converting VSS files can be found in the VSS-tools github repository.\nThis documentation gives you an overview of VSS:\nIntroduction Read this part if you want to know more about what the specification is all about, what’s in and out and how to quickly browse through the current status.",
    "tags": [],
    "title": "Vehicle Signal Specification",
    "uri": "/vehicle_signal_specification/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/vehicle_signal_specification/categories/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/vehicle_signal_specification/tags/index.html"
  }
]
